//

class ManpageUtil abstract {
	/// Localization of the string described by 1st argument.
	/// Returns localized string or second arg if string cannot be found.
	static String Locz( String loczid, String empty = "" ) {
		String cellname;
		String localized;

		if ( loczid.CharAt( 0 ) == "$" ) {
			cellname = loczid.Mid( 1 );
			localized = StringTable.Localize( loczid );
		} else {
			cellname = loczid;
			localized = StringTable.Localize( "$" .. loczid );
		}

		if ( localized == cellname || localized == "" )
			return empty; // Compatible comparison for all GZDoom versions.

		return localized;
	}
} // of class ManpageUtil abstract {}


class ManpageRecord {
	String id; // LANGUAGE lump identifier, like "SUMMON".
	//String nameid; // Pre-parsed LANGUAGE lump name identifier, like "$MANPAGES_CCMD_SUMMON_NAME".
	//String descid; // Pre-parsed LANGUAGE lump description identifier, like "$MANPAGES_CCMD_SUMMON_DESC".
	//String exmpid; // Pre-parsed LANGUAGE lump examples identifier, like "$MANPAGES_CCMD_SUMMON_EXMP".

	String nm;
	Array<String> aliases;

	const const_MaxHeaderFieldWidth = 25;

	static ManpageRecord Create( String initname, String initid ) {
		ManpageRecord newrec = new( 'ManpageRecord' );
		newrec.nm = initname;
		newrec.id = initid;

		return newrec;
	}


	virtual String Get( void ) {
		String outstr = "";

		String manheader = ManpageUtil.Locz( String.Format( "MANPAGES_%s_NAME", id ) );
		String mandesc = ManpageUtil.Locz( String.Format( "MANPAGES_%s_DESC", id ) );
		String manexamples = ManpageUtil.Locz( String.Format( "MANPAGES_%s_EXMP", id ) );

		// Dummy beautifying.

		// Header (cmdname + args):
		int argsstartpos = manheader.IndexOf( " " );
		String mancmdname;

		if ( argsstartpos != -1 ) {
			mancmdname = manheader.Left( argsstartpos );
			manheader = mancmdname .. TEXTCOLOR_RED .. manheader.Mid( argsstartpos );
		} else {
			mancmdname = manheader;
		}

		outstr = "| " .. TEXTCOLOR_BRICK .. manheader .. TEXTCOLOR_NORMAL;

		// Aliases (if any):
		if ( aliases.Size() != 0 ) {
			String argsdots = ( mancmdname != manheader? "..." : "" );

			for ( int i = 0; i < aliases.Size(); i++ )
				outstr.AppendFormat( "\n|  \cu%s \cj%s \cu%s\c-", ManpageUtil.Locz( "MANPAGES_GENERAL_ALIAS_PREFIX" ), aliases[ i ], argsdots );
		}

		// Description (if exists):
		if ( mandesc != "" ) {
			mandesc.Replace( "{{", TEXTCOLOR_LIGHTBLUE );
			mandesc.Replace( "}}", TEXTCOLOR_NORMAL );
			outstr.AppendFormat( "\n\c-|\n%s\n", mandesc );
		} else {
			outstr.AppendFormat( "\n\cu%s\c-", ManpageUtil.Locz( "MANPAGES_GENERAL_NO_DESCRIPTION" ) );
		}

		// Examples (if any):
		if ( manexamples != "" ) {
			Array<String> examples, eheaders, edescs;
			int maxheaderlength = 0;

			manexamples.Split( examples, "\n", TOK_KEEPEMPTY );

			// Split by header/desc, find max header length and apply special colors:
			for ( int i = 0; i < examples.Size(); i++ ) {
				int tabindex = examples[ i ].IndexOf( "\t" );

				if ( tabindex != -1 ) {
					String eheader = examples[ i ].Left( tabindex );
					String edesc = examples[ i ].Mid( tabindex + 1 );

					edesc.Replace( "{{", TEXTCOLOR_LIGHTBLUE );
					edesc.Replace( "}}", TEXTCOLOR_NORMAL );

		            eheader.Replace( mancmdname, TEXTCOLOR_BRICK .. mancmdname .. TEXTCOLOR_RED );
					eheader.Replace( "{{", TEXTCOLOR_LIGHTBLUE );
					eheader.Replace( "}}", TEXTCOLOR_RED );

					int eheaderlength = eheader.Length();

					eheaders.Push( eheader );
					edescs.Push( edesc );

					if ( eheaderlength > maxheaderlength && eheaderlength <= const_MaxHeaderFieldWidth )
						maxheaderlength = eheaderlength;

					//examples[ i ] = "";
				} else {
					examples[ i ].Replace( "{{", TEXTCOLOR_LIGHTBLUE );
					examples[ i ].Replace( "}}", TEXTCOLOR_NORMAL );

					eheaders.Push( "" );
					edescs.Push( "" );
				}
			}

			// Post-init:
			outstr.AppendFormat( "\n%s\n", ManpageUtil.Locz( "MANPAGES_GENERAL_EXAMPLES" ) );

			// Indirect evaluation of the field width (actually this is the same as "%*s" format specifier in C's `printf()`):
			String headerformat = String.Format( "%%-%is", ( maxheaderlength > const_MaxHeaderFieldWidth ? const_MaxHeaderFieldWidth : maxheaderlength ) );

			// Print all examples in proper format:
			for ( int i = 0; i < examples.Size(); i++ ) {
				if ( eheaders[ i ] != "" )
					outstr.AppendFormat( headerformat .. " \cu- \c-%s\n", eheaders[ i ], edescs[ i ] );
				else
					outstr.AppendFormat( "%s\n", examples[ i ] );
			}
		} // of if ( manexamples != "" ) {}

		return outstr;
	} // of virtual String Get( void ) {}
} // of class ManpageRecord {}


class ManpagesEventHandler: StaticEventHandler {
	/// A queue of file handles. All new handles are stored at the end of the queue.
	Array<int> configIncludeFileHandles;

	/// Guardian counter to prevent recursions and infinite loops.
	private int configParsedFilesAmount;
	const const_MaxConfigFilesAmount = 32;

	/// Main storage.
	Array<ManpageRecord> pages;



	/// Internal method just to beautify the output.
	private String MessageFilePos( int filehandle, int filelinenum ) {
		return String.Format( "in file '%s' line %i", WADs.GetLumpFullName( filehandle ), filelinenum + 1 );
	}

	/// Searches for a manpage by page name.
	/// Returns `ManpageRecord` or NULL if manpage not found.
	protected ManpageRecord FindPageByName( String pagename ) {
		for ( int i = 0; i < pages.Size(); i++ ) {
			if ( pages[ i ].nm == pagename )
				return pages[ i ];
		}

		return NULL;
	} // of protected ManpageRecord FindPageByName( String pagename ) {}


	/// Seaches for a given file name in a global namespace.
	/// If `starthandle` is "-1", searches for full path instead of the root.
	/// Returns -1 if file cannot be found or a valid file handle otherwise.
	int SearchConfigFile( String filename, int starthandle = 0 ) {
		int handle;

		if ( starthandle < 0 )
			handle = WADs.CheckNumForFullName( filename );
		else
			handle = WADs.FindLump( filename, starthandle );

		if ( configParsedFilesAmount > const_MaxConfigFilesAmount ) {
			console.printf( "Tried to add too many config files (%i) when processing include path '%s'.", const_MaxConfigFilesAmount, filename );
			handle = -1;

		} else if ( handle != -1 ) {
			configIncludeFileHandles.Push( handle );
			configParsedFilesAmount++;
		}

		return handle;
	} // of int SearchConfigFile( String filename, int starthandle = 0 ) {}


	/// Returns NULL if LANGUAGE identifier cannot be found, or a valid pointer otherwise.
	ManpageRecord AddManpageFile( String pagename, String loczid ) {
		ManpageRecord manpage = NULL;

		if ( ManpageUtil.Locz( "$MANPAGES_" .. loczid .. "_NAME" ) != "" ) {
			manpage = ManpageRecord.Create( pagename, loczid );
			pages.Push( manpage );

			if ( ManpageUtil.Locz( "$MANPAGES_" .. loczid .. "_DESC" ) == "" )
				console.printf( "Empty description for manpage '%s'.", pagename );
		}

		return manpage;
	} // of ManpageRecord AddManpageFile( String pagename, String loczid ) {}

	ManpageRecord AddManpageAlias( String pagename, String pagealias ) {
		ManpageRecord page = FindPageByName( pagename );

		if ( !page )
			return NULL; // Manpage for alias not found.

		page.aliases.Push( pagealias );
		return page;
	}


	/// Main config files parsing method.
	/// Returns nothing, extensively works with many internal variables.
	void ParseConfigFile( int filehandle ) {
		Array<String> lines;
		String cfgtext = WADs.ReadLump( filehandle );
		cfgtext.Replace( "\t", " " );
		cfgtext.Split( lines, "\n" );

		// Iterate over all lines:
		for ( int i = 0; i < lines.Size(); i++ ) {
			String ln = lines[ i ];

			// Remove comments:
			int commentpos = ln.IndexOf( "#" );

			if ( commentpos != -1 )
				ln = ln.Left( commentpos );

			if ( ln == "" )
				continue; // Skip empty lines.

			// Take apart all args in string:
			Array<String> lnargv;
			ln.Split( lnargv, " ", TOK_SKIPEMPTY );

			String lncommand = lnargv[ 0 ];
			int lnargc = lnargv.Size();
			lncommand.ToLower();


			// Commands processing.

			// Add new file to the parsing stack:
			if ( lncommand == "include" && lnargc == 2 ) {
				if ( -1 == SearchConfigFile( lnargv[ 1 ], -1 ) )
					console.printf( "Wrong include path '%s' %s.", lnargv[ 1 ], MessageFilePos( filehandle, i ) );

			// Add new page to the main manpages storage:
			} else if ( lncommand == "page" && lnargc == 3 ) {
				if ( NULL == AddManpageFile( lnargv[ 1 ], lnargv[ 2 ] ) )
					console.printf( "Wrong manpage '%s' with ID '%s' %s.", lnargv[ 1 ], lnargv[ 2 ], MessageFilePos( filehandle, i ) );

			// Alias from one command to another:
			} else if ( lncommand == "alias" ) {
				if ( NULL == AddManpageAlias( lnargv[ 2 ], lnargv[ 1 ] ) )
					console.printf( "Wrong manpage '%s' to link with alias '%s' %s.", lnargv[ 2 ], lnargv[ 1 ], MessageFilePos( filehandle, i ) );

				//console.printf( "Not implemented: alias '%s' -> '%s' %s.", lnargv[ 1 ], lnargv[ 2 ], MessageFilePos( filehandle, i ) );

			} else {
				console.printf( "Unknown command '%s' with argc %i %s.", lncommand, lnargc, MessageFilePos( filehandle, i ) );

			}
		}

		configIncludeFileHandles.Delete( 0 );
	} // of void ParseConfigFile( int filehandle ) {}


	override void OnRegister() {

		// Config files parsing.

		int lastconfigfd = 0;
		int curconfigfd = 0;

		// Add all high-level files from all *.pk3:
		do {
			curconfigfd = SearchConfigFile( "manpages/manpages.cfg", lastconfigfd );
			lastconfigfd = curconfigfd + 1;
		} while ( curconfigfd != -1 && configParsedFilesAmount < const_MaxConfigFilesAmount );

		// Parse all files, also from directive "include PATH":
		while ( configIncludeFileHandles.Size() != 0 ) {
			ParseConfigFile( configIncludeFileHandles[ 0 ] );
		}

		// As said, no manpage configuration files was found.
		if ( configParsedFilesAmount == 0 )
			console.printf( "No manpage config files found." );

		Super.OnRegister();
	} // of override void OnRegister() {}

	ui void ManpageProcess( String cmd ) {
		// Dummy processing for now.
		if ( cmd ~== "list" ) {
			int pagessize = pages.Size();

			String liststr = "";

			for ( int i = 0; i < pagessize; i++ ) {
				if ( pages[ i ].aliases.Size() > 0 )
					liststr.AppendFormat( "%s %s+ %i alias(es)%s, ", pages[ i ].nm, TEXTCOLOR_DARKGRAY, pages[ i ].aliases.Size(), TEXTCOLOR_NORMAL );
				else
					liststr.AppendFormat( "%s, ", pages[ i ].nm );
			}

			liststr = "[" .. liststr.Left( liststr.Length() - 2 ) .. "]";


			console.printf( liststr );
			return;
		}

		// Empty string and some other "keywords" results in help about `man` itself.
		if ( cmd == "" || cmd == "help" || cmd == "-h" || cmd == "--help" || cmd == "/?" || cmd == "?" )
			cmd = "man";

		ManpageRecord foundpage = NULL;

		for ( int i = 0; i < pages.Size(); i++ ) {
			ManpageRecord page = pages[ i ];

			if ( page.nm == cmd ) {
				// Compare command name.
				foundpage = page;
				break;

			} else if ( page.aliases.Size() != 0 ) {
				// Compare command aliases (if any).
				for ( int j = 0; j < page.aliases.Size(); j++ ) {
					if ( page.aliases[ j ] == cmd ) {
						foundpage = page;
						break; // For aliases/`j` cycle.
					}
				}

				if ( foundpage )
					break; // For pages/`i` cycle.
			}
		} // of for ( int i = 0; i < pages.Size(); i++ ) {}

		if ( foundpage )
			console.printf( "%s", foundpage.Get() );
		else
			console.printf( "\cu" .. ManpageUtil.Locz( "$MANPAGES_GENERAL_NO_PAGE" ), cmd );
	} // of void ManpageProcess( String cmd ) {}

	override void ConsoleProcess( ConsoleEvent e ) {
		if ( e.Name.Left( 9 ) == "manpages`" ) {
			ManpageProcess( e.Name.Mid( 9 ) );
		}

		Super.ConsoleProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {}

} // of class ManpagesEventHandler: StaticEventHandler {}
