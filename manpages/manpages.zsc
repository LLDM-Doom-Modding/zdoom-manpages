//

class ManpageUtil abstract {
	/// Localization of the string described by 1st argument.
	/// Returns localized string or second arg if string cannot be found.
	static String Locz( String langid, String empty = "" ) {
		String localized = StringTable.Localize(
				String.Format( "%s%s", ( langid.CharAt( 0 ) == "$"? "" : "$" ), langid )
			);

		if ( localized == langid )
			return empty;

		return localized;
	}
} // of class ManpageUtil abstract {}


class ManpageRecord {
	String id; // LANGUAGE lump identifier, like "SUMMON".
	//String nameid; // Pre-parsed LANGUAGE lump name identifier, like "$MANPAGES_CCMD_SUMMON_NAME".
	//String descid; // Pre-parsed LANGUAGE lump description identifier, like "$MANPAGES_CCMD_SUMMON_DESC".
	//String exmpid; // Pre-parsed LANGUAGE lump examples identifier, like "$MANPAGES_CCMD_SUMMON_EXMP".

	String nm;

	static ManpageRecord Create( String initname, String initid ) {
		ManpageRecord newrec = new( 'ManpageRecord' );
		newrec.nm = initname;
		newrec.id = initid;

		return newrec;
	}


	virtual String Get( void ) {
		String outstr = "";

		String manheader = ManpageUtil.Locz( String.Format( "MANPAGES_%s_NAME", id ) );
		String mandesc = ManpageUtil.Locz( String.Format( "MANPAGES_%s_DESC", id ) );
		String manexamples = ManpageUtil.Locz( String.Format( "MANPAGES_%s_EXMP", id ) );

		// Dummy beautifying.

		// Header (cmdname + args):
		int argsstartpos = manheader.IndexOf( " " );
		String mancmdname;

		if ( argsstartpos != -1 ) {
			mancmdname = manheader.Left( argsstartpos );
			manheader = "\cj" .. mancmdname .. "\cg" .. manheader.Mid( argsstartpos ) .. "\c-";
		} else {
			mancmdname = manheader;
		}

		outstr = "| " .. manheader;

		// Description (if exists):
		if ( mandesc != "" ) {
			mandesc.Replace( "{{", "\cn" );
			mandesc.Replace( "}}", "\c-" );
			outstr.AppendFormat( "\n|\n%s\n", mandesc );
		} else {
			outstr.AppendFormat( "\cu%s\c-", ManpageUtil.Locz( "MANPAGES_GENERAL_NO_DESCRIPTION" ) );
		}

		// Examples (if any):
		if ( manexamples != "" ) {
			manexamples.Replace( mancmdname, "\cj" .. mancmdname .. "\cg" );
			manexamples.Replace( "\t", "  \cu-- \c-" );

			outstr.AppendFormat( "\n%s\n%s", ManpageUtil.Locz( "MANPAGES_GENERAL_EXAMPLES" ), manexamples );
		}

		return outstr;
	} // of virtual String Get( void ) {}
} // of class ManpageRecord {}


class ManpagesEventHandler: StaticEventHandler {
	/// A queue of file handles. All new handles are stored at the end of the queue.
	Array<int> configIncludeFileHandles;

	/// Guardian counter to prevent recursions and infinite loops.
	private int configParsedFilesAmount;
	const const_MaxConfigFilesAmount = 32;

	/// Main storage.
	Array<ManpageRecord> pages;



	/// Internal method just to beautify the output.
	private String MessageFilePos( int filehandle, int filelinenum ) {
		return String.Format( "in file '%s' line %i", WADs.GetLumpFullName( filehandle ), filelinenum + 1 );
	}


	/// Seaches for a given file name in a global namespace.
	/// If `starthandle` is "-1", searches for full path instead of the root.
	/// Returns -1 if file cannot be found or a valid file handle otherwise.
	int SearchConfigFile( String filename, int starthandle = 0 ) {
		int handle;

		if ( starthandle < 0 )
			handle = WADs.CheckNumForFullName( filename );
		else
			handle = WADs.FindLump( filename, starthandle );

		if ( configParsedFilesAmount > const_MaxConfigFilesAmount ) {
			console.printf( "Tried to add too many config files (%i) when processing include path '%s'.", const_MaxConfigFilesAmount, filename );
			handle = -1;

		} else if ( handle != -1 ) {
			configIncludeFileHandles.Push( handle );
			configParsedFilesAmount++;
		}

		return handle;
	} // of int SearchConfigFile( String filename, int starthandle = 0 ) {}


	/// Returns NULL if LANGUAGE identifier cannot be found, or a valid pointer otherwise.
	ManpageRecord AddManpageFile( String pagename, String langid ) {
		ManpageRecord manpage = NULL;

		if ( ManpageUtil.Locz( "$MANPAGE_" .. langid .. "_NAME" ) != "" ) {
			manpage = ManpageRecord.Create( pagename, langid );
			pages.Push( manpage );
		}

		return manpage;
	} // of ManpageRecord AddManpageFile( String pagename, String langid ) {}


	/// Main config files parsing method.
	/// Returns nothing, extensively works with many internal variables.
	void ParseConfigFile( int filehandle ) {
		Array<String> lines;
		String cfgtext = WADs.ReadLump( filehandle );
		cfgtext.Replace( "\t", " " );
		cfgtext.Split( lines, "\n" );

		// Iterate over all lines:
		for ( int i = 0; i < lines.Size(); i++ ) {
			String ln = lines[ i ];

			// Remove comments:
			int commentpos = ln.IndexOf( "#" );

			if ( commentpos != -1 )
				ln = ln.Left( commentpos );

			if ( ln == "" )
				continue; // Skip empty lines.

			// Take apart all args in string:
			Array<String> lnargv;
			ln.Split( lnargv, " ", TOK_SKIPEMPTY );

			String lncommand = lnargv[ 0 ];
			int lnargc = lnargv.Size();
			lncommand.ToLower();


			// Commands processing.

			// Add new file to the parsing stack:
			if ( lncommand == "include" && lnargc == 2 ) {
				if ( -1 == SearchConfigFile( lnargv[ 1 ], -1 ) )
					console.printf( "Wrong include path '%s' %s.", lnargv[ 1 ], MessageFilePos( filehandle, i ) );

			// Add new page to the main manpages storage:
			} else if ( lncommand == "page" && lnargc == 3 ) {
				if ( NULL == AddManpageFile( lnargv[ 1 ], lnargv[ 2 ] ) )
					console.printf( "Wrong manpage '%s' with ID '%s' %s.", lnargv[ 1 ], lnargv[ 2 ], MessageFilePos( filehandle, i ) );

			// Alias from one command to another:
			} else if ( lncommand == "alias" ) {
				console.printf( "Not implemented: alias '%s' -> '%s' %s.", lnargv[ 1 ], lnargv[ 2 ], MessageFilePos( filehandle, i ) );

			} else {
				console.printf( "Unknown command '%s' with argc %i %s.", lncommand, lnargc, MessageFilePos( filehandle, i ) );

			}
		}

		configIncludeFileHandles.Delete( 0 );
	} // of void ParseConfigFile( int filehandle ) {}


	override void OnRegister() {

		// Config files parsing.

		int lastconfigfd = 0;
		int curconfigfd = 0;

		// Add all high-level files from all *.pk3:
		do {
			curconfigfd = SearchConfigFile( "manpages/manpages.cfg", lastconfigfd );
			lastconfigfd = curconfigfd + 1;
		} while ( curconfigfd != -1 && configParsedFilesAmount < const_MaxConfigFilesAmount );

		// Parse all files, also from directive "include PATH":
		while ( configIncludeFileHandles.Size() != 0 ) {
			ParseConfigFile( configIncludeFileHandles[ 0 ] );
		}

		// As said, no manpage configuration files was found.
		if ( configParsedFilesAmount == 0 )
			console.printf( "No manpage config files found." );

		Super.OnRegister();
	} // of override void OnRegister() {}

	void ManpageProcess( String cmd ) {
		// Dummy processing for now.
		if ( cmd ~== "list" ) {
			int pagessize = pages.Size();

			String liststr = "[";

			for ( int i = 0; i < pagessize - 1; i++ ) {
				liststr.AppendFormat( "%s, ", pages[ i ].nm );
			}

			if ( pagessize > 0 )
				liststr.AppendFormat( "%s]", pages[ pagessize - 1 ].nm );
			else
				liststr = "[]";

			console.printf( liststr );
			return;
		}

		// Empty string results in help about `man` itself.
		if ( cmd == "" )
			cmd = "man";

		bool manpagefound = false;

		for ( int i = 0; i < pages.Size(); i++ ) {
			if ( pages[ i ].nm == cmd ) {
				console.printf( "%s", pages[ i ].Get() );
				manpagefound = true;
				break;
			}
		}

		if ( !manpagefound )
			console.printf( "\cu" .. ManpageUtil.Locz( "$MANPAGES_GENERAL_NO_PAGE" ), cmd );
	} // of void ManpageProcess( String cmd ) {}

	override void NetworkProcess( ConsoleEvent e ) {
		if ( e.Name.Left( 9 ) == "manpages`" ) {
			ManpageProcess( e.Name.Mid( 9 ) );
		}

		Super.NetworkProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {}

} // of class ManpagesEventHandler: StaticEventHandler {}
