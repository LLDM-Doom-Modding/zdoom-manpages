//

class ManpageUtil abstract {
	/// Localization of the string described by 1st argument.
	/// Returns localized string or second arg if string cannot be found.
	static String Locz( String loczid, String empty = "" ) {
		String cellname;
		String localized;

		if ( loczid.CharAt( 0 ) == "$" ) {
			cellname = loczid.Mid( 1 );
			localized = StringTable.Localize( loczid );
		} else {
			cellname = loczid;
			localized = StringTable.Localize( "$" .. loczid );
		}

		if ( localized == cellname || localized == "" )
			return empty; // Compatible comparison for all GZDoom versions.

		return localized;
	}

	/// Compares the first characters of `str` with `startswith`.
	/// Returns `true` if `str` begins with `startswith`, otherwise `false`.
	static bool StrStartsWith( String str, String startswith ) {
		int startswithlen = startswith.Length();

		return !!( str.Left( startswithlen ) == startswith );
	}

	/// Returns new string equal to `str` without the leading `prefix`.
	static String StrWithoutPrefix( String str, String prefix ) {
		int prefixlen = prefix.Length();

		return str.Mid( prefixlen );
	}

	/// . Note: this is not a compatible version, old versions will not run with them.
	/// Returns new string with separator `joinsep` between every neighbour cells.
	static String StrJoin( in Array<String> strarr, String joinsep = "," ) {
		int strarrsize = strarr.Size();

		if ( strarrsize < 2 )
			return ( strarrsize == 0 ? "" : strarr[ 0 ] ); // Too small array to join.

		// Main joining cycle.
		String outstr = strarr[ 0 ];

		for ( int i = 1; i < strarrsize; i++ )
			outstr.AppendFormat( "%s%s", joinsep, strarr[ i ] );

		return outstr;
	}

	/// Replaces "{{a highlighting syntax}}" with proper colors. For now no colors stack etc.
	/// Returns a new string, original string isn't affected by highlighting.
	static String StrHighlightCurlyBraces( in String input, String highlightcolor = TEXTCOLOR_LIGHTBLUE, String normalcolor = TEXTCOLOR_NORMAL ) {
		input.Replace( "{{", highlightcolor );
		input.Replace( "}}", normalcolor );

		return input;
	}
} // of class ManpageUtil abstract {}


class ManpageRecord {
	String id; // LANGUAGE lump identifier, like "SUMMON".
	//String nameid; // Pre-parsed LANGUAGE lump name identifier, like "$MANPAGES_CCMD_SUMMON_NAME".
	//String descid; // Pre-parsed LANGUAGE lump description identifier, like "$MANPAGES_CCMD_SUMMON_DESC".
	//String exmpid; // Pre-parsed LANGUAGE lump examples identifier, like "$MANPAGES_CCMD_SUMMON_EXMP".

	String nm;
	Array<String> aliases;

	const const_MaxHeaderFieldWidth = 25;

	static ManpageRecord Create( String initname, String initid ) {
		ManpageRecord newrec = new( 'ManpageRecord' );
		newrec.nm = initname;
		newrec.id = initid;

		return newrec;
	}

	String GetHeaderLocalized( void ) {
		return ManpageUtil.Locz( String.Format( "MANPAGES_%s_NAME", id ) );
	}

	String GetDescLocalized( void ) {
		return ManpageUtil.Locz( String.Format( "MANPAGES_%s_DESC", id ) );
	}

	String GetExamplesLocalized( void ) {
		return ManpageUtil.Locz( String.Format( "MANPAGES_%s_EXMP", id ) );
	}

	virtual String Get( void ) {
		String outstr = "";

		String manheader = GetHeaderLocalized();
		String mandesc = GetDescLocalized();
		String manexamples = GetExamplesLocalized();

		// Dummy beautifying.

		// Header (cmdname + args):
		int argsstartpos = manheader.IndexOf( " " );
		String mancmdname;

		if ( argsstartpos != -1 ) {
			mancmdname = manheader.Left( argsstartpos );
			manheader = mancmdname .. TEXTCOLOR_RED .. manheader.Mid( argsstartpos );
		} else {
			mancmdname = manheader;
		}

		outstr = "| " .. TEXTCOLOR_BRICK .. manheader .. TEXTCOLOR_NORMAL;

		// Aliases (if any):
		if ( aliases.Size() != 0 ) {
			String argsdots = ( mancmdname != manheader? "..." : "" );

			for ( int i = 0; i < aliases.Size(); i++ )
				outstr.AppendFormat( "\n|  \cu%s \cj%s \cu%s\c-", ManpageUtil.Locz( "MANPAGES_GENERAL_ALIAS_PREFIX" ), aliases[ i ], argsdots );
		}

		// Description (if exists):
		if ( mandesc != "" ) {
			outstr.AppendFormat( "\n\c-|\n%s\n", ManpageUtil.StrHighlightCurlyBraces( mandesc ) );
		} else {
			outstr.AppendFormat( "\n\cu%s\c-", ManpageUtil.Locz( "MANPAGES_GENERAL_NO_DESCRIPTION" ) );
		}

		// Examples (if any):
		if ( manexamples != "" ) {
			Array<String> examples, eheaders, edescs;
			int maxheaderlength = 0;

			manexamples.Split( examples, "\n", TOK_KEEPEMPTY );

			// Split by header/desc, find max header length and apply special colors:
			for ( int i = 0; i < examples.Size(); i++ ) {
				int tabindex = examples[ i ].IndexOf( "\t" );

				if ( tabindex != -1 ) {
					String eheader = examples[ i ].Left( tabindex );
					String edesc = examples[ i ].Mid( tabindex + 1 );

					edesc = ManpageUtil.StrHighlightCurlyBraces( edesc );

		            eheader.Replace( mancmdname, TEXTCOLOR_BRICK .. mancmdname .. TEXTCOLOR_RED );
					eheader = ManpageUtil.StrHighlightCurlyBraces( eheader, TEXTCOLOR_LIGHTBLUE, TEXTCOLOR_RED );

					int eheaderlength = eheader.Length();

					eheaders.Push( eheader );
					edescs.Push( edesc );

					if ( eheaderlength > maxheaderlength && eheaderlength <= const_MaxHeaderFieldWidth )
						maxheaderlength = eheaderlength;

					//examples[ i ] = "";
				} else {
					examples[ i ] = ManpageUtil.StrHighlightCurlyBraces( examples[ i ] );

					eheaders.Push( "" );
					edescs.Push( "" );
				}
			}

			// Post-init:
			outstr.AppendFormat( "\n%s\n", ManpageUtil.Locz( "MANPAGES_GENERAL_EXAMPLES" ) );

			// Indirect evaluation of the field width (actually this is the same as "%*s" format specifier in C's `printf()`):
			String headerformat = String.Format( "%%-%is", ( maxheaderlength > const_MaxHeaderFieldWidth ? const_MaxHeaderFieldWidth : maxheaderlength ) );

			// Print all examples in proper format:
			for ( int i = 0; i < examples.Size(); i++ ) {
				if ( eheaders[ i ] != "" )
					outstr.AppendFormat( headerformat .. " \cu- \c-%s\n", eheaders[ i ], edescs[ i ] );
				else
					outstr.AppendFormat( "%s\n", examples[ i ] );
			}
		} // of if ( manexamples != "" ) {}

		return outstr;
	} // of virtual String Get( void ) {}

	/// Returns `true` if current page name equals to `checknm`.
	/// Case-sensitive check, but `checknm` should already be in lowercase.
	bool CheckName( String checknm ) {
		if ( nm == checknm ) {
			return true;

		} else if ( aliases.Size() != 0 ) {
			// Compare command aliases (if any).
			for ( int j = 0; j < aliases.Size(); j++ ) {
				if ( aliases[ j ] == checknm )
					return true;
			}
		}

		return false;
	}

	/// Returns `true` if current page text has `origpattern`.
	/// Full manpage text is converted to lowercase. `origpattern` should already be in lowercase.
	bool CheckSearch( String origpattern ) {
		String pattern = origpattern;

		if ( CheckName( pattern ) )
			return true;

		String manfulltext = GetDescLocalized() .. GetExamplesLocalized();
		manfulltext.ToLower();

		return !!( manfulltext.IndexOf( pattern ) != -1 );
	}
} // of class ManpageRecord {}


class ManpagesEventHandler: StaticEventHandler {
	/// A queue of file handles. All new handles are stored at the end of the queue.
	Array<int> configIncludeFileHandles;

	/// Guardian counter to prevent recursions and infinite loops.
	private int configParsedFilesAmount;
	const const_MaxConfigFilesAmount = 32;
	const const_MaxSearchArgsLimit = 10; // ZDoom's console commands number of arguments is limited to the number of substitutions defined in KEYCONF.
	const const_MaxSearchOutputDescriptionLength = 128;

	/// Main storage.
	Array<ManpageRecord> pages;


	/// Internal method just to beautify the output.
	private String MessageFilePos( int filehandle, int filelinenum ) {
		return String.Format( "in file '%s' line %i", WADs.GetLumpFullName( filehandle ), filelinenum + 1 );
	}

	/// Searches for a manpage by page name.
	/// Returns `ManpageRecord` or NULL if manpage not found.
	protected ManpageRecord FindPageByName( String pagename ) {
		for ( int i = 0; i < pages.Size(); i++ ) {
			if ( pages[ i ].nm == pagename )
				return pages[ i ];
		}

		return NULL;
	} // of protected ManpageRecord FindPageByName( String pagename ) {}


	/// Seaches for a given file name in a global namespace.
	/// If `starthandle` is "-1", searches for full path instead of the root.
	/// Returns -1 if file cannot be found or a valid file handle otherwise.
	int SearchConfigFile( String filename, int starthandle = 0 ) {
		int handle;

		if ( starthandle < 0 )
			handle = WADs.CheckNumForFullName( filename );
		else
			handle = WADs.FindLump( filename, starthandle );

		if ( configParsedFilesAmount > const_MaxConfigFilesAmount ) {
			console.printf( "Tried to add too many config files (%i) when processing include path '%s'.", const_MaxConfigFilesAmount, filename );
			handle = -1;

		} else if ( handle != -1 ) {
			configIncludeFileHandles.Push( handle );
			configParsedFilesAmount++;
		}

		return handle;
	} // of int SearchConfigFile( String filename, int starthandle = 0 ) {}


	/// Returns NULL if LANGUAGE identifier cannot be found, or a valid pointer otherwise.
	ManpageRecord AddManpageFile( String pagename, String loczid ) {
		ManpageRecord manpage = NULL;

		if ( ManpageUtil.Locz( "$MANPAGES_" .. loczid .. "_NAME" ) != "" ) {
			manpage = ManpageRecord.Create( pagename, loczid );
			pages.Push( manpage );

			if ( ManpageUtil.Locz( "$MANPAGES_" .. loczid .. "_DESC" ) == "" )
				console.printf( "Empty description for manpage '%s'.", pagename );
		}

		return manpage;
	} // of ManpageRecord AddManpageFile( String pagename, String loczid ) {}

	ManpageRecord AddManpageAlias( String pagename, String pagealias ) {
		ManpageRecord page = FindPageByName( pagename );

		if ( !page )
			return NULL; // Manpage for alias not found.

		page.aliases.Push( pagealias );
		return page;
	}


	/// Main config files parsing method.
	/// Returns nothing, extensively works with many internal variables.
	void ParseConfigFile( int filehandle ) {
		Array<String> lines;
		String cfgtext = WADs.ReadLump( filehandle );
		cfgtext.Replace( "\t", " " );
		cfgtext.Split( lines, "\n" );

		// Iterate over all lines:
		for ( int i = 0; i < lines.Size(); i++ ) {
			String ln = lines[ i ];

			// Remove comments:
			int commentpos = ln.IndexOf( "#" );

			if ( commentpos != -1 )
				ln = ln.Left( commentpos );

			if ( ln == "" )
				continue; // Skip empty lines.

			// Take apart all args in string:
			Array<String> lnargv;
			ln.Split( lnargv, " ", TOK_SKIPEMPTY );

			String lncommand = lnargv[ 0 ];
			int lnargc = lnargv.Size();
			lncommand.ToLower();


			// Commands processing.

			// Add new file to the parsing stack:
			if ( lncommand == "include" && lnargc == 2 ) {
				if ( -1 == SearchConfigFile( lnargv[ 1 ], -1 ) )
					console.printf( "Wrong include path '%s' %s.", lnargv[ 1 ], MessageFilePos( filehandle, i ) );

			// Add new page to the main manpages storage:
			} else if ( lncommand == "page" && lnargc == 3 ) {
				if ( NULL == AddManpageFile( lnargv[ 1 ], lnargv[ 2 ] ) )
					console.printf( "Wrong manpage '%s' with ID '%s' %s.", lnargv[ 1 ], lnargv[ 2 ], MessageFilePos( filehandle, i ) );

			// Alias from one command to another:
			} else if ( lncommand == "alias" ) {
				if ( NULL == AddManpageAlias( lnargv[ 2 ], lnargv[ 1 ] ) )
					console.printf( "Wrong manpage '%s' to link with alias '%s' %s.", lnargv[ 2 ], lnargv[ 1 ], MessageFilePos( filehandle, i ) );

				//console.printf( "Not implemented: alias '%s' -> '%s' %s.", lnargv[ 1 ], lnargv[ 2 ], MessageFilePos( filehandle, i ) );

			} else {
				console.printf( "Unknown command '%s' with argc %i %s.", lncommand, lnargc, MessageFilePos( filehandle, i ) );

			}
		}

		configIncludeFileHandles.Delete( 0 );
	} // of void ParseConfigFile( int filehandle ) {}


	override void OnRegister() {

		// Config files parsing.

		int lastconfigfd = 0;
		int curconfigfd = 0;

		// Add all high-level files from all *.pk3:
		do {
			curconfigfd = SearchConfigFile( "manpages/manpages.cfg", lastconfigfd );
			lastconfigfd = curconfigfd + 1;
		} while ( curconfigfd != -1 && configParsedFilesAmount < const_MaxConfigFilesAmount );

		// Parse all files, also from directive "include PATH":
		while ( configIncludeFileHandles.Size() != 0 ) {
			ParseConfigFile( configIncludeFileHandles[ 0 ] );
		}

		// As said, no manpage configuration files was found.
		if ( configParsedFilesAmount == 0 )
			console.printf( "No manpage config files found." );

		Super.OnRegister();
	} // of override void OnRegister() {}


	/// Process the "man ..." command. `rawarg` is a command passed to "man" (manpage or keyword like "--help").
	ui void ManpageProcess( String rawarg ) {
		// Dummy processing for now.
		if ( rawarg ~== "list" ) {
			int pagessize = pages.Size();

			String liststr = "";

			for ( int i = 0; i < pagessize; i++ ) {
				if ( pages[ i ].aliases.Size() > 0 )
					liststr.AppendFormat( "%s %s+ %i alias(es)%s, ", pages[ i ].nm, TEXTCOLOR_DARKGRAY, pages[ i ].aliases.Size(), TEXTCOLOR_NORMAL );
				else
					liststr.AppendFormat( "%s, ", pages[ i ].nm );
			}

			liststr = "[" .. liststr.Left( liststr.Length() - 2 ) .. "]";


			console.printf( liststr );
			return;
		}

		// Empty string and some other "keywords" results in help about `man` itself.
		if ( rawarg == "" || rawarg == "help" || rawarg == "-h" || rawarg == "--help" || rawarg == "/?" || rawarg == "?" )
			rawarg = "man";

		ManpageRecord foundpage = NULL;

		for ( int i = 0; i < pages.Size(); i++ ) {
			if ( pages[ i ].CheckName( rawarg ) ) {
				foundpage = pages[ i ];
				break;
			}
		} // of for ( int i = 0; i < pages.Size(); i++ ) {}

		if ( foundpage )
			console.printf( "%s", foundpage.Get() );
		else
			console.printf( TEXTCOLOR_DARKGRAY .. ManpageUtil.Locz( "$MANPAGES_GENERAL_NO_PAGE" ), rawarg );
	} // of void ManpageProcess( String rawarg ) {}

	/// Process the "man-search ..." command.
	/// `rawarg` is a pattern passed to "man-search".
	ui void ManpageSearchProcess( String rawarg ) {
		//Array<String> includes, excludes; // Pattern parts to search / to exclude from search.
		Array<String> includes;
		rawarg.Split( includes, "`", TOK_SKIPEMPTY );
		int includessize = includes.Size();

		if ( includessize == 0 ) {
			console.printf( TEXTCOLOR_DARKGRAY .. ManpageUtil.Locz( "$MANPAGES_GENERAL_NO_SEARCH_PATTERN" ) );

			/*CVar prevlangcvar = CVar.FindCVar( "__manpages_language_previous" );
			CVar unicodewarningcvar = CVar.FindCVar( "__manpages_unicode_warning" );
			console.printf( "prevlangcvar 0x" .. prevlangcvar .. ", unicodewarningcvar 0x" .. unicodewarningcvar );

			if ( prevlangcvar && !ManpageUtil.StrStartsWith( prevlangcvar.GetString(), "en" ) )
				unicodewarningcvar.SetInt( 1 );
				//console.printf( TEXTCOLOR_YELLOW .. ManpageUtil.Locz( "$MANPAGES_GENERAL_SEARCH_PROBABLY_UNICODE" ) );
			*/

			return; // No search pattern provided, nothing to search for.
		}

		if ( includessize > const_MaxSearchArgsLimit ) {
			// ZDoom's console commands number of arguments is limited to the number of substitutions defined in KEYCONF.
			console.printf( TEXTCOLOR_DARKGRAY .. ManpageUtil.Locz( "$MANPAGES_GENERAL_SEARCH_ARGS_LIMIT" ), const_MaxSearchArgsLimit );
		}


		// Search for included words:
		Array<ManpageRecord> foundpages;
		String incl0 = includes[ 0 ];

		for ( int i = 0; i < pages.Size(); i++ ) {
			ManpageRecord page = pages[ i ];

			// Check for at least the first include word:
			if ( !page.CheckSearch( incl0 ) )
				continue; // Not match the first include word. Next pages[] iteration.

			if ( includessize == 1 ) {
				foundpages.Push( page );
				continue; // Match the only include word. Next pages[] iteration.
			}

			// Check for all other includes[] (all other words to search):
			bool allmatches = true;

			for ( int j = 1; j < includessize; j++ ) {
				if ( !page.CheckSearch( includes[ j ] ) ) {
					allmatches = false;
					break; // No match, page must be skipped. Break the includes[] cycle.
				}
			}

			if ( allmatches )
				foundpages.Push( page );
		} // of for ( int i = 0; i < pages.Size(); i++ ) {}


		int foundpagessize = foundpages.Size();

		if ( foundpagessize == 0 ) {
			console.printf( TEXTCOLOR_DARKGRAY .. ManpageUtil.Locz( "$MANPAGES_GENERAL_SEARCH_NOT_MATCH" ), ManpageUtil.StrJoin( includes, " " ) );
			return; // Search found nothing with this pattern.
		}

		// Print the results:
		for ( int i = 0; i < foundpagessize; i++ ) {
			ManpageRecord page = foundpages[ i ];

			String header = page.GetHeaderLocalized();
			int headerargsstartpos = header.IndexOf( " " );
			String headerccmd = ( headerargsstartpos == -1 ? header : header.Left( headerargsstartpos ) );

			String desc = ManpageUtil.StrHighlightCurlyBraces( page.GetDescLocalized() );
			int desccharindex;
			int desctrunclen = const_MaxSearchOutputDescriptionLength - headerccmd.Length();

			if ( -1 != ( desccharindex = desc.IndexOf( "\n" ) ) && desccharindex < desctrunclen )
				desctrunclen = desccharindex;

			if ( desc.Length() > desctrunclen )
				desc = desc.Left( desctrunclen ) .. TEXTCOLOR_DARKGRAY .. "...";

			console.printf( TEXTCOLOR_BRICK .. " %s" .. TEXTCOLOR_DARKGRAY .. " - " .. TEXTCOLOR_NORMAL .. "%s", headerccmd, desc );
		}
	} // of ui void ManpageSearchProcess( String rawarg ) {}

	override void ConsoleProcess( ConsoleEvent e ) {
		String ccmdname = e.name;
		ccmdname.ToLower(); // Make case-insensitive.

		if ( ManpageUtil.StrStartsWith( ccmdname, "manpages`" ) ) {
			// Command "man ...".
			ManpageProcess( ManpageUtil.StrWithoutPrefix( ccmdname, "manpages`" ) );

		} else if ( ManpageUtil.StrStartsWith( ccmdname, "manpages-search`" ) ) {
			// Command "man-search ...".
			//console.printf( "\cuccmdname == '%s'", ccmdname );
			ManpageSearchProcess( ManpageUtil.StrWithoutPrefix( ccmdname, "manpages-search`" ) );

		} else if ( ManpageUtil.StrStartsWith( ccmdname, "manpages-unicode-warning`" ) ) {
			// Unicode warning message on the current locale.

			bool enlang = ManpageUtil.StrStartsWith( language, "en" );

			if ( ManpageUtil.StrWithoutPrefix( ccmdname, "manpages-unicode-warning`" ) == "" && !enlang )
				console.printf( TEXTCOLOR_YELLOW .. ManpageUtil.Locz( "$MANPAGES_GENERAL_SEARCH_PROBABLY_UNICODE" ) );
		}

		Super.ConsoleProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {}

} // of class ManpagesEventHandler: StaticEventHandler {}
